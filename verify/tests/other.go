package tests

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/madkins23/go-slog/infra"
	"github.com/madkins23/go-slog/internal/warning"
)

// -----------------------------------------------------------------------------
// Other tests.

// TestLevelConfigured tests whether the source logger is created by default in
// SimpleOptions() and SourceOptions() with slog.LevelInfo.
//   - Other tests (e.g. TestDisabled) depend on this.
//
// Note: this doesn't test the handler's default level but
// but the one generated by the test suite functions mentioned above.
func (suite *SlogTestSuite) TestLevelConfigured() {
	for _, options := range []*slog.HandlerOptions{
		infra.SimpleOptions(),
		infra.SourceOptions(),
	} {
		logger := suite.Logger(options)
		suite.Assert().False(logger.Enabled(context.Background(), -1))
		suite.Assert().True(logger.Enabled(context.Background(), slog.LevelInfo))
		suite.checkLevelMath(logger, 1, true,
			"1  is not enabled when INFO is set")
		suite.Assert().True(logger.Enabled(context.Background(), slog.LevelWarn))
		suite.Assert().True(logger.Enabled(context.Background(), slog.LevelError))
	}
}

// TestLevelDifferent tests whether the simple logger can be created with slog.LevelWarn.
// This verifies the test suite can change the level when creating a logger.
// It also verifies changing the level via the handler.
//   - https://pkg.go.dev/log/slog@master#HandlerOptions
func (suite *SlogTestSuite) TestLevelDifferent() {
	logger := suite.Logger(infra.LevelOptions(slog.LevelWarn))
	suite.Assert().False(logger.Enabled(context.Background(), -1))
	suite.Assert().False(logger.Enabled(context.Background(), slog.LevelInfo))
	suite.Assert().False(logger.Enabled(context.Background(), 3))
	suite.Assert().True(logger.Enabled(context.Background(), slog.LevelWarn))
	suite.checkLevelMath(logger, 5, true,
		"5  is not enabled when WARN is set")
	suite.Assert().True(logger.Enabled(context.Background(), slog.LevelError))
	logger = suite.Logger(&slog.HandlerOptions{
		Level:     slog.LevelWarn,
		AddSource: true,
	})
	suite.Assert().False(logger.Enabled(context.Background(), -1))
	suite.Assert().False(logger.Enabled(context.Background(), slog.LevelInfo))
	suite.Assert().False(logger.Enabled(context.Background(), 1))
	suite.Assert().True(logger.Enabled(context.Background(), slog.LevelWarn))
	suite.checkLevelMath(logger, 5, true,
		"5  is not enabled when WARN is set")
	suite.Assert().True(logger.Enabled(context.Background(), slog.LevelError))
}

// TestGroupDuration checks to see if time.Duration objects are logged the same
// whether they are in a Group or at the top level of the log item.
//   - Based on common sense, duration objects should log the same everywhere.
func (suite *SlogTestSuite) TestGroupDuration() {
	duration := 8*time.Hour + 3*time.Minute + 22*time.Second
	logger := suite.Logger(infra.SimpleOptions())
	logger.With("outer", duration).WithGroup("group").Info(message, "inner", duration)
	logMap := suite.logMap()
	out, found := logMap["outer"]
	suite.Require().True(found)
	outer, ok := out.(float64)
	suite.Require().True(ok)
	grp, found := logMap["group"]
	suite.Require().True(found)
	group, ok := grp.(map[string]any)
	suite.Require().True(ok)
	in, found := group["inner"]
	suite.Require().True(found)
	inner, ok := in.(float64)
	suite.Require().True(ok)
	if !suite.HasWarning(warning.GroupDuration) {
		suite.Assert().Equal(outer, inner)
	} else if outer == inner {
		suite.AddUnused(warning.GroupDuration, suite.Buffer.String())
	} else {
		suite.AddWarning(warning.GroupDuration,
			fmt.Sprintf("%f != %f", outer, inner), suite.Buffer.String())
	}
}

// TestGroupWithTop tests ...
func (suite *SlogTestSuite) TestGroupWithTop() {
	logger := suite.Logger(infra.SimpleOptions())
	logger.WithGroup("group").With(slog.String("key", "value")).Info(message)
	logMap := suite.logMap()
	if !suite.HasWarning(warning.GroupWithTop) {
		grp, found := logMap["group"]
		suite.Require().True(found)
		group, ok := grp.(map[string]any)
		suite.Require().True(ok)
		str, found := group["key"]
		suite.Require().True(found)
		suite.Assert().Equal("value", str)
		return
	}
	if grp, found := logMap["group"]; found {
		if group, ok := grp.(map[string]any); ok {
			if str, found := group["key"]; found {
				if val, ok := str.(string); ok {
					if "value" == val {
						suite.AddUnused(warning.GroupWithTop, "")
						return
					}
				}
			}
		}
	}
	if str, found := logMap["key"]; found {
		if val, ok := str.(string); ok {
			if val == "value" {
				suite.AddWarning(warning.GroupWithTop, "", suite.Buffer.String())
				return
			}
		}
	}
	// TODO: should there be a warning or fail() here?
}

// TestTimestampFormat tests whether a timestamp can be parsed.
//   - Based on the existing behavior of log/slog the timestamp format is RFC3339.
func (suite *SlogTestSuite) TestTimestampFormat() {
	logger := suite.Logger(infra.SimpleOptions())
	logger.Info(message)
	logMap := suite.logMap()
	suite.checkFieldCount(3, logMap)
	timeObj := suite.parseTime(logMap[slog.TimeKey])
	suite.Assert().Equal(time.Now().Year(), timeObj.Year())
	suite.Assert().Equal(time.Now().Month(), timeObj.Month())
	suite.Assert().Equal(time.Now().Day(), timeObj.Day())
}
