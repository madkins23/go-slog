package tests

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
	"time"

	warning2 "github.com/madkins23/go-slog/infra/warning"
)

// -----------------------------------------------------------------------------
// Methods for checks common to various tests or too long to put in a test.

// checkFieldCount checks whether the prescribed number of fields exist at the top level.
// In addition to using the logMap generated by unmarshaling the JSON log data,
// the custom test.FieldCounter is used to make sure there are no duplicates.
func (suite *SlogTestSuite) checkFieldCount(fieldCount uint, logMap map[string]any) {
	if suite.HasWarning(warning2.Duplicates) {
		counter := suite.fieldCounter()
		suite.Require().NoError(counter.Parse())
		if len(counter.Duplicates()) > 0 {
			suite.AddWarning(warning2.Duplicates, fmt.Sprintf("%v", counter.Duplicates()), "")
			return
		}
	}
	suite.Assert().Len(logMap, int(fieldCount))
	// Double check to make sure there are no duplicate fields at the top level.
	counter := suite.fieldCounter()
	suite.Require().NoError(counter.Parse())
	suite.Assert().Equal(fieldCount, counter.NumFields())
	suite.Assert().Empty(counter.Duplicates())
}

func (suite *SlogTestSuite) checkLevelKey(level string, logMap map[string]any) {
	// The log/slog.JSONHandler generates uppercase.
	level = strings.ToUpper(level)
	if suite.HasWarning(warning2.LevelCase) {
		if logLevel, ok := logMap[slog.LevelKey].(string); ok {
			if level != strings.ToUpper(logLevel) {
				suite.AddWarning(warning2.LevelWrong, fmt.Sprintf("should be '%s', not '%s'", level, logLevel), "")
				return
			} else if level != logLevel {
				suite.AddWarning(warning2.LevelCase, "'"+logLevel+"'", "")
				return
			}
		}
		suite.AddUnused(warning2.LevelCase, "")
		return
	}
	suite.Assert().Equal(level, logMap[slog.LevelKey])
}

func (suite *SlogTestSuite) checkLevelMath(
	logger *slog.Logger, level slog.Level, wantEnabled bool, message string) {
	good := logger.Enabled(context.Background(), level) == wantEnabled
	if !suite.HasWarning(warning2.LevelMath) {
		suite.Assert().True(good)
	} else if good {
		suite.AddUnused(warning2.LevelMath, "")
	} else {
		suite.AddWarning(warning2.LevelMath, message, "")
	}
}

func (suite *SlogTestSuite) checkMessageKey(message string, logMap map[string]any) {
	if suite.HasWarning(warning2.MessageKey) {
		if _, found := logMap[slog.MessageKey]; found {
			// Something exists for the proper key so fall through to test assertion.
		} else if msg, found := logMap["message"]; found {
			// Found something on the known alternate key.
			if message == msg {
				suite.AddWarning(warning2.MessageKey, "`message`", "")
				return
			}
		}
		suite.AddUnused(warning2.MessageKey, "")
	}
	suite.Assert().Equal(message, logMap[slog.MessageKey])
}

func (suite *SlogTestSuite) checkNoEmptyAttribute(fieldCount uint, logMap map[string]any) {
	if suite.HasWarning(warning2.EmptyAttributes) {
		// Warn for logging of empty attribute.
		counter := suite.fieldCounter()
		suite.Require().NoError(counter.Parse())
		if counter.NumFields() == fieldCount+1 {
			if value, found := logMap[""]; found && value == nil {
				suite.AddWarning(warning2.EmptyAttributes, "", suite.Buffer.String())
				return
			}
		}
		suite.AddUnused(warning2.EmptyAttributes, "")
	}
	suite.checkFieldCount(fieldCount, logMap)
	_, found := logMap[""]
	suite.Assert().False(found)
}

func (suite *SlogTestSuite) checkResolution(value any, actual any) {
	if suite.HasWarning(warning2.Resolver) {
		if value != actual {
			suite.AddWarning(warning2.Resolver, "", suite.Buffer.String())
			return
		}
		suite.AddUnused(warning2.Resolver, "")
	}
	suite.Assert().Equal(value, actual)
}

var sourceKeys = map[string]any{
	"file":     "",
	"function": "",
	"line":     123.456,
}

func (suite *SlogTestSuite) checkSourceKey(fieldCount uint, logMap map[string]any) {
	if suite.HasWarning(warning2.SourceCaller) {
		if sourceCaller, found := logMap["caller"]; found {
			if text, ok := sourceCaller.(string); ok {
				if suite.HasWarning(warning2.SourceKey) {
					suite.AddUnused(warning2.SourceKey, "")
				}
				suite.AddWarning(warning2.SourceCaller, text, suite.String())
				return
			}
		}
		suite.AddUnused(warning2.SourceCaller, suite.String())
	}
	if suite.HasWarning(warning2.SourceKey) {
		if sourceCaller, found := logMap["caller"]; found {
			if text, ok := sourceCaller.(string); ok {
				suite.AddWarning(warning2.SourceCaller, text, suite.String())
			}
		}
		sourceData, found := logMap[slog.SourceKey]
		if !found || sourceData == nil {
			text := "no 'source' key"
			if found {
				text = "'source' key is nil"
			}
			suite.AddWarning(warning2.SourceKey, text, suite.Buffer.String())
			return
		}
		source, ok := sourceData.(map[string]any)
		if !ok {
			suite.AddWarning(warning2.SourceKey, "'source' key not a group", suite.Buffer.String())
			return
		}
		var text strings.Builder
		sep := ""
		for field := range sourceKeys {
			var state string
			value := source[field]
			if value == nil {
				state = "missing"
			} else if _, ok := value.(string); !ok {
				state = "not a string"
			}
			if state != "" {
				text.WriteString(fmt.Sprintf("%s%s: %s", sep, field, state))
				sep = ", "
			}
		}
		if text.Len() > 0 {
			suite.AddWarning(warning2.SourceKey, text.String(), suite.Buffer.String())
			return
		}
		suite.AddUnused(warning2.SourceKey, suite.String())
	}
	suite.checkFieldCount(fieldCount, logMap)
	if group, ok := logMap[slog.SourceKey].(map[string]any); ok {
		suite.Assert().Len(group, 3)
		for field, exemplar := range sourceKeys {
			suite.Assert().NotNil(group[field])
			suite.Assert().IsType(exemplar, group[field], "key: "+field)
		}
	} else {
		suite.Fail("Group not map[string]any")
	}
}

func (suite *SlogTestSuite) parseTime(timeAny any) time.Time {
	suite.Assert().NotNil(timeAny)
	timeStr, ok := timeAny.(string)
	suite.Assert().True(ok)
	timeObj, err := time.Parse(time.RFC3339, timeStr)
	suite.Assert().NoError(err)
	return timeObj
}
